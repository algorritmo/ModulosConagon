<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>Filtro ADSR</title>
  <script src="https://code.jquery.com/jquery-3.6.0.min.js">
  </script>
  <script>
    (function (e) { if (typeof define === "function" && define.amd) { define(["jquery"], e) } else { e(jQuery) } })(function (e) { "use strict"; var t = {}, n = Math.max, r = Math.min; t.c = {}; t.c.d = e(document); t.c.t = function (e) { return e.originalEvent.touches.length - 1 }; t.o = function () { var n = this; this.o = null; this.$ = null; this.i = null; this.g = null; this.v = null; this.cv = null; this.x = 0; this.y = 0; this.w = 0; this.h = 0; this.$c = null; this.c = null; this.t = 0; this.isInit = false; this.fgColor = null; this.pColor = null; this.dH = null; this.cH = null; this.eH = null; this.rH = null; this.scale = 1; this.relative = false; this.relativeWidth = false; this.relativeHeight = false; this.$div = null; this.run = function () { var t = function (e, t) { var r; for (r in t) { n.o[r] = t[r] } n._carve().init(); n._configure()._draw() }; if (this.$.data("kontroled")) return; this.$.data("kontroled", true); this.extend(); this.o = e.extend({ min: this.$.data("min") !== undefined ? this.$.data("min") : 0, max: this.$.data("max") !== undefined ? this.$.data("max") : 100, stopper: true, readOnly: this.$.data("readonly") || this.$.attr("readonly") === "readonly", cursor: this.$.data("cursor") === true && 30 || this.$.data("cursor") || 0, thickness: this.$.data("thickness") && Math.max(Math.min(this.$.data("thickness"), 1), .01) || .35, lineCap: this.$.data("linecap") || "butt", width: this.$.data("width") || 200, height: this.$.data("height") || 200, displayInput: this.$.data("displayinput") == null || this.$.data("displayinput"), displayPrevious: this.$.data("displayprevious"), fgColor: this.$.data("fgcolor") || "#87CEEB", inputColor: this.$.data("inputcolor"), font: this.$.data("font") || "Arial", fontWeight: this.$.data("font-weight") || "bold", inline: false, step: this.$.data("step") || 1, rotation: this.$.data("rotation"), draw: null, change: null, cancel: null, release: null, format: function (e) { return e }, parse: function (e) { return parseFloat(e) } }, this.o); this.o.flip = this.o.rotation === "anticlockwise" || this.o.rotation === "acw"; if (!this.o.inputColor) { this.o.inputColor = this.o.fgColor } if (this.$.is("fieldset")) { this.v = {}; this.i = this.$.find("input"); this.i.each(function (t) { var r = e(this); n.i[t] = r; n.v[t] = n.o.parse(r.val()); r.bind("change blur", function () { var e = {}; e[t] = r.val(); n.val(n._validate(e)) }) }); this.$.find("legend").remove() } else { this.i = this.$; this.v = this.o.parse(this.$.val()); this.v === "" && (this.v = this.o.min); this.$.bind("change blur", function () { n.val(n._validate(n.o.parse(n.$.val()))) }) } !this.o.displayInput && this.$.hide(); this.$c = e(document.createElement("canvas")).attr({ width: this.o.width, height: this.o.height }); this.$div = e('<div style="' + (this.o.inline ? "display:inline;" : "") + "width:" + this.o.width + "px;height:" + this.o.height + "px;" + '"></div>'); this.$.wrap(this.$div).before(this.$c); this.$div = this.$.parent(); if (typeof G_vmlCanvasManager !== "undefined") { G_vmlCanvasManager.initElement(this.$c[0]) } this.c = this.$c[0].getContext ? this.$c[0].getContext("2d") : null; if (!this.c) { throw { name: "CanvasNotSupportedException", message: "Canvas not supported. Please use excanvas on IE8.0.", toString: function () { return this.name + ": " + this.message } } } this.scale = (window.devicePixelRatio || 1) / (this.c.webkitBackingStorePixelRatio || this.c.mozBackingStorePixelRatio || this.c.msBackingStorePixelRatio || this.c.oBackingStorePixelRatio || this.c.backingStorePixelRatio || 1); this.relativeWidth = this.o.width % 1 !== 0 && this.o.width.indexOf("%"); this.relativeHeight = this.o.height % 1 !== 0 && this.o.height.indexOf("%"); this.relative = this.relativeWidth || this.relativeHeight; this._carve(); if (this.v instanceof Object) { this.cv = {}; this.copy(this.v, this.cv) } else { this.cv = this.v } this.$.bind("configure", t).parent().bind("configure", t); this._listen()._configure()._xy().init(); this.isInit = true; this.$.val(this.o.format(this.v)); this._draw(); return this }; this._carve = function () { if (this.relative) { var e = this.relativeWidth ? this.$div.parent().width() * parseInt(this.o.width) / 100 : this.$div.parent().width(), t = this.relativeHeight ? this.$div.parent().height() * parseInt(this.o.height) / 100 : this.$div.parent().height(); this.w = this.h = Math.min(e, t) } else { this.w = this.o.width; this.h = this.o.height } this.$div.css({ width: this.w + "px", height: this.h + "px" }); this.$c.attr({ width: this.w, height: this.h }); if (this.scale !== 1) { this.$c[0].width = this.$c[0].width * this.scale; this.$c[0].height = this.$c[0].height * this.scale; this.$c.width(this.w); this.$c.height(this.h) } return this }; this._draw = function () { var e = true; n.g = n.c; n.clear(); n.dH && (e = n.dH()); e !== false && n.draw() }; this._touch = function (e) { var r = function (e) { var t = n.xy2val(e.originalEvent.touches[n.t].pageX, e.originalEvent.touches[n.t].pageY); if (t == n.cv) return; if (n.cH && n.cH(t) === false) return; n.change(n._validate(t)); n._draw() }; this.t = t.c.t(e); r(e); t.c.d.bind("touchmove.k", r).bind("touchend.k", function () { t.c.d.unbind("touchmove.k touchend.k"); n.val(n.cv) }); return this }; this._mouse = function (e) { var r = function (e) { var t = n.xy2val(e.pageX, e.pageY); if (t == n.cv) return; if (n.cH && n.cH(t) === false) return; n.change(n._validate(t)); n._draw() }; r(e); t.c.d.bind("mousemove.k", r).bind("keyup.k", function (e) { if (e.keyCode === 27) { t.c.d.unbind("mouseup.k mousemove.k keyup.k"); if (n.eH && n.eH() === false) return; n.cancel() } }).bind("mouseup.k", function (e) { t.c.d.unbind("mousemove.k mouseup.k keyup.k"); n.val(n.cv) }); return this }; this._xy = function () { var e = this.$c.offset(); this.x = e.left; this.y = e.top; return this }; this._listen = function () { if (!this.o.readOnly) { this.$c.bind("mousedown", function (e) { e.preventDefault(); n._xy()._mouse(e) }).bind("touchstart", function (e) { e.preventDefault(); n._xy()._touch(e) }); this.listen() } else { this.$.attr("readonly", "readonly") } if (this.relative) { e(window).resize(function () { n._carve().init(); n._draw() }) } return this }; this._configure = function () { if (this.o.draw) this.dH = this.o.draw; if (this.o.change) this.cH = this.o.change; if (this.o.cancel) this.eH = this.o.cancel; if (this.o.release) this.rH = this.o.release; if (this.o.displayPrevious) { this.pColor = this.h2rgba(this.o.fgColor, "0.4"); this.fgColor = this.h2rgba(this.o.fgColor, "0.6") } else { this.fgColor = this.o.fgColor } return this }; this._clear = function () { this.$c[0].width = this.$c[0].width }; this._validate = function (e) { var t = ~~((e < 0 ? -.5 : .5) + e / this.o.step) * this.o.step; return Math.round(t * 100) / 100 }; this.listen = function () { }; this.extend = function () { }; this.init = function () { }; this.change = function (e) { }; this.val = function (e) { }; this.xy2val = function (e, t) { }; this.draw = function () { }; this.clear = function () { this._clear() }; this.h2rgba = function (e, t) { var n; e = e.substring(1, 7); n = [parseInt(e.substring(0, 2), 16), parseInt(e.substring(2, 4), 16), parseInt(e.substring(4, 6), 16)]; return "rgba(" + n[0] + "," + n[1] + "," + n[2] + "," + t + ")" }; this.copy = function (e, t) { for (var n in e) { t[n] = e[n] } } }; t.Dial = function () { t.o.call(this); this.startAngle = null; this.xy = null; this.radius = null; this.lineWidth = null; this.cursorExt = null; this.w2 = null; this.PI2 = 2 * Math.PI; this.extend = function () { this.o = e.extend({ bgColor: this.$.data("bgcolor") || "#EEEEEE", angleOffset: this.$.data("angleoffset") || 0, angleArc: this.$.data("anglearc") || 360, inline: true }, this.o) }; this.val = function (e, t) { if (null != e) { e = this.o.parse(e); if (t !== false && e != this.v && this.rH && this.rH(e) === false) { return } this.cv = this.o.stopper ? n(r(e, this.o.max), this.o.min) : e; this.v = this.cv; this.$.val(this.o.format(this.v)); this._draw() } else { return this.v } }; this.xy2val = function (e, t) { var i, s; i = Math.atan2(e - (this.x + this.w2), -(t - this.y - this.w2)) - this.angleOffset; if (this.o.flip) { i = this.angleArc - i - this.PI2 } if (this.angleArc != this.PI2 && i < 0 && i > -.5) { i = 0 } else if (i < 0) { i += this.PI2 } s = i * (this.o.max - this.o.min) / this.angleArc + this.o.min; this.o.stopper && (s = n(r(s, this.o.max), this.o.min)); return s }; this.listen = function () { var t = this, i, s, o = function (e) { e.preventDefault(); var o = e.originalEvent, u = o.detail || o.wheelDeltaX, a = o.detail || o.wheelDeltaY, f = t._validate(t.o.parse(t.$.val())) + (u > 0 || a > 0 ? t.o.step : u < 0 || a < 0 ? -t.o.step : 0); f = n(r(f, t.o.max), t.o.min); t.val(f, false); if (t.rH) { clearTimeout(i); i = setTimeout(function () { t.rH(f); i = null }, 100); if (!s) { s = setTimeout(function () { if (i) t.rH(f); s = null }, 200) } } }, u, a, f = 1, l = { 37: -t.o.step, 38: t.o.step, 39: t.o.step, 40: -t.o.step }; this.$.bind("keydown", function (i) { var s = i.keyCode; if (s >= 96 && s <= 105) { s = i.keyCode = s - 48 } u = parseInt(String.fromCharCode(s)); if (isNaN(u)) { s !== 13 && s !== 8 && s !== 9 && s !== 189 && (s !== 190 || t.$.val().match(/\./)) && i.preventDefault(); if (e.inArray(s, [37, 38, 39, 40]) > -1) { i.preventDefault(); var o = t.o.parse(t.$.val()) + l[s] * f; t.o.stopper && (o = n(r(o, t.o.max), t.o.min)); t.change(t._validate(o)); t._draw(); a = window.setTimeout(function () { f *= 2 }, 30) } } }).bind("keyup", function (e) { if (isNaN(u)) { if (a) { window.clearTimeout(a); a = null; f = 1; t.val(t.$.val()) } } else { t.$.val() > t.o.max && t.$.val(t.o.max) || t.$.val() < t.o.min && t.$.val(t.o.min) } }); this.$c.bind("mousewheel DOMMouseScroll", o); this.$.bind("mousewheel DOMMouseScroll", o) }; this.init = function () { if (this.v < this.o.min || this.v > this.o.max) { this.v = this.o.min } this.$.val(this.v); this.w2 = this.w / 2; this.cursorExt = this.o.cursor / 100; this.xy = this.w2 * this.scale; this.lineWidth = this.xy * this.o.thickness; this.lineCap = this.o.lineCap; this.radius = this.xy - this.lineWidth / 2; this.o.angleOffset && (this.o.angleOffset = isNaN(this.o.angleOffset) ? 0 : this.o.angleOffset); this.o.angleArc && (this.o.angleArc = isNaN(this.o.angleArc) ? this.PI2 : this.o.angleArc); this.angleOffset = this.o.angleOffset * Math.PI / 180; this.angleArc = this.o.angleArc * Math.PI / 180; this.startAngle = 1.5 * Math.PI + this.angleOffset; this.endAngle = 1.5 * Math.PI + this.angleOffset + this.angleArc; var e = n(String(Math.abs(this.o.max)).length, String(Math.abs(this.o.min)).length, 2) + 2; this.o.displayInput && this.i.css({ width: (this.w / 2 + 4 >> 0) + "px", height: (this.w / 3 >> 0) + "px", position: "absolute", "vertical-align": "middle", "margin-top": (this.w / 3 >> 0) + "px", "margin-left": "-" + (this.w * 3 / 4 + 2 >> 0) + "px", border: 0, background: "none", font: this.o.fontWeight + " " + (this.w / e >> 0) + "px " + this.o.font, "text-align": "center", color: this.o.inputColor || this.o.fgColor, padding: "0px", "-webkit-appearance": "none" }) || this.i.css({ width: "0px", visibility: "hidden" }) }; this.change = function (e) { this.cv = e; this.$.val(this.o.format(e)) }; this.angle = function (e) { return (e - this.o.min) * this.angleArc / (this.o.max - this.o.min) }; this.arc = function (e) { var t, n; e = this.angle(e); if (this.o.flip) { t = this.endAngle + 1e-5; n = t - e - 1e-5 } else { t = this.startAngle - 1e-5; n = t + e + 1e-5 } this.o.cursor && (t = n - this.cursorExt) && (n = n + this.cursorExt); return { s: t, e: n, d: this.o.flip && !this.o.cursor } }; this.draw = function () { var e = this.g, t = this.arc(this.cv), n, r = 1; e.lineWidth = this.lineWidth; e.lineCap = this.lineCap; if (this.o.bgColor !== "none") { e.beginPath(); e.strokeStyle = this.o.bgColor; e.arc(this.xy, this.xy, this.radius, this.endAngle - 1e-5, this.startAngle + 1e-5, true); e.stroke() } if (this.o.displayPrevious) { n = this.arc(this.v); e.beginPath(); e.strokeStyle = this.pColor; e.arc(this.xy, this.xy, this.radius, n.s, n.e, n.d); e.stroke(); r = this.cv == this.v } e.beginPath(); e.strokeStyle = r ? this.o.fgColor : this.fgColor; e.arc(this.xy, this.xy, this.radius, t.s, t.e, t.d); e.stroke() }; this.cancel = function () { this.val(this.v) } }; e.fn.dial = e.fn.knob = function (n) { return this.each(function () { var r = new t.Dial; r.o = n; r.$ = e(this); r.run() }).parent() } })
  </script>
  <style type="text/css">
    .container {
      overflow-x: scroll;
      overflow-y: hidden;
      width: 100%;
      height: 180px;
      white-space: nowrap;
      margin: 10px;
    }

    .keyboard {
      width: auto;
      padding: 0;
      margin: 0;
    }

    .key-set-parent {
      position: relative;
      display: inline-block;
      width: 40px;
      height: 120px;
    }

    .key {
      position: relative;
      cursor: pointer;
      font: 10px "Open Sans", "Lucida Grande", "Arial", sans-serif;
      border: 1px solid black;
      border-radius: 5px;
      width: 40px;
      height: 120px;
      text-align: center;
      box-shadow: 2px 2px darkgray;
      display: inline-block;
      margin-right: 3px;
      user-select: none;
      -moz-user-select: none;
      -webkit-user-select: none;
      -ms-user-select: none;
    }

    .key.black-key {
      position: absolute;
      background-color: #000;
      color: #fff;
      width: 36px;
      height: 80px;
      top: 0px;
      left: 22px;
      z-index: 1;
      pointer-events: auto;
      vertical-align: top;
    }

    .key div {
      position: absolute;
      bottom: 0;
      text-align: center;
      width: 100%;
      pointer-events: none;
    }

    .key div sub {
      font-size: 8px;
      pointer-events: none;
    }

    .key:hover {
      background-color: #eef;
    }

    .key.black-key:hover {
      background-color: #778;
    }

    .key:active {
      background-color: #000;
      color: #fff;
    }

    .key.black-key:active {
      background-color: #fff;
      color: #000;
    }

    .octave {
      display: inline-block;
      padding: 0 6px 0 0;
    }

    .settingsBar {
      padding-top: 8px;
      font: 14px "Open Sans", "Lucida Grande", "Arial", sans-serif;
      position: relative;
      vertical-align: middle;
      width: 100%;
      height: 60px;
    }

    .left {
      width: 50%;
      position: absolute;
      left: 0;
      display: table-cell;
      vertical-align: middle;
    }

    .left span,
    .left input {
      vertical-align: middle;
    }

    .right {
      width: 50%;
      position: absolute;
      right: 0;
      display: table-cell;
      vertical-align: middle;
    }

    .right span {
      vertical-align: middle;
    }

    .right input {
      vertical-align: baseline;
    }

    .envelope-fieldset {
      padding-top: 8px;
      position: relative;
      font: 18px "Open Sans", "Lucida Grande", "Arial", sans-serif;
      left: 0;
      display: table-cell;
      border-style: solid;
      vertical-align: middle;
      border-color: #000;
      background-color: #eee;
    }

    .table-border-none,
    .table-border-none td {
      font: 14px "Open Sans", "Lucida Grande", "Arial", sans-serif;
      left: 0;
      width: 45%;
      vertical-align: middle;
      white-space: nowrap;
      border: none;
    }


    .header {
      margin-bottom: 20px;
    }

    .container1 {
      display: flex;
    }

    .oscilador-container,
    .knob-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 50%;
      margin: 10px;
    }

    /* Switch Togle*/

    .switch {
      position: relative;
      display: inline-block;
      width: 60px;
      height: 24px;
    }

    /* Hide default HTML checkbox */
    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    /* The slider */
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      -webkit-transition: .4s;
      transition: .4s;
    }

    .slider:before {
      position: absolute;
      content: "";
      height: 20px;
      width: 20px;
      left: 4px;
      bottom: 3px;
      background-color: white;
      -webkit-transition: .4s;
      transition: .4s;
    }

    input:checked+.slider {
      background-color: #2196F3;
    }

    input:focus+.slider {
      box-shadow: 0 0 1px #2196F3;
    }

    input:checked+.slider:before {
      -webkit-transform: translateX(29px);
      -ms-transform: translateX(29px);
      transform: translateX(29px);
    }

    /* Rounded sliders */
    .slider.round {
      border-radius: 34px;
    }

    .slider.round:before {
      border-radius: 50%;
    }
  </style>
</head>

<body>
  <div class="container1">
    <div class="oscilador-container">
      <!-- Contenido del primer oscilador -->
      <h2>Forma de Onda Oscilador 1</h2>
      <!--<input id="frequency-slider1" type="range" min="0" max="1000" step="10">-->
      <input id="waveform-knob1" type="text" value="0">
      <Label>OFF/ON</Label>
      <!-- Rounded switch -->
      <label class="switch">
        <input type="checkbox" id="btnOnOsc1" value="false">
        <span class="slider round"></span>
      </label>
    </div>

    <div class="knob-container">
      <!-- Contenido del segundo oscilador -->
      <h2>Forma de Onda Oscilador 2</h2>
      <!--<input id="frequency-slider2" type="range" min="0" max="1000" step="10"> -->
      <input id="waveform-knob2" type="text" value="0">
      <Label>OFF/ON</Label>
      <!-- Rounded switch -->
      <label class="switch">
        <input type="checkbox" id="btnOnOsc2" value="false">
        <span class="slider round"></span>
      </label>
    </div>
  </div>
  <div class="container">
    <div class="keyboard"></div>
  </div>

  <fieldset class="envelope-fieldset">
    <legend>Filtro ADSR</legend>

    <table class="table-border-none">
      <tr>
        <td>Attack:<br />(Time)</td>
        <td>0%</td>
        <td><input type="range" min="0.0" max="1.0" step="0.01" value="0.1" name="attack"></td>
        <td>100%</td>

        <td>Release:<br />(Time)</td>
        <td>0%</td>
        <td><input type="range" min="0.0" max="1.0" step="0.01" value="0.5" name="release"></td>
        <td>100%</td>
      </tr>

      <tr>
        <td>Decay:<br />(Time)</td>
        <td>0%</td>
        <td><input type="range" min="0.0" max="1.0" step="0.01" value="0.5" name="decay"></td>
        <td>100%</td>

        <td>Time<br />Scale:</td>
        <td>0.0(s)</td>
        <td><input type="range" min="0.0" max="2.0" step="0.01" value="1.0" name="time-scale"></td>
        <td>2.0(s)</td>
      </tr>

      <tr>
        <td>Sustain:<br />(Volume)</td>
        <td>0%</td>
        <td><input type="range" min="0.0" max="1.0" step="0.01" value="0.5" name="sustain"></td>
        <td>100%</td>

        <td></td>
        <td></td>
        <td></td>
        <td></td>
      </tr>
    </table>
  </fieldset>

  <div class="settingsBar">
    <div class="left">
      <table class="table-border-none">
        <tr>
          <td>Volume: </td>
          <td>Mute<input type="range" min="0.0" max="1.0" step="0.01" value="0.5" name="volume">100%</td>
        </tr>
      </table>
    </div>

    <!--
    <div class="right">
      <span>Current waveform: </span>
      <select name="waveform">
        <option value="sine">Sine</option>
        <option value="square">Square</option>
        <option value="sawtooth">Sawtooth</option>
        <option value="triangle" selected>Triangle</option>
        <option value="custom">Custom</option>
      </select>
    </div>
    -->
  </div>

  <script>
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();

    const oscillatorMap = new Map();
    const gainNodeMap = new Map();

    var oscillator1;
    var oscillator2;



    // Variable para controlar el estado de la tecla (inicialmente, ninguna tecla está presionada)
    let keyIsPressed = false;
    let keyup = false;

    let noteFreq = null;
    let customWaveform = null;
    let sineTerms = null;
    let cosineTerms = null;


    const keyboard = document.querySelector(".keyboard");
    let wavePicker1 = null // document.querySelector("select[name='waveform']");
    let wavePicker2 = null
    const volumeControl = document.querySelector("input[name='volume']");
    const attackControl = document.querySelector("input[name='attack']");
    const decayControl = document.querySelector("input[name='decay']");
    const sustainControl = document.querySelector("input[name='sustain']");
    const releaseControl = document.querySelector("input[name='release']");
    const timeScaleControl = document.querySelector("input[name='time-scale']");

    $('#waveform-knob1').knob({
      'min': 0,
      'max': 4,
      'step': 1,
      'change': function (value) {
        if (oscillator1 || audioContext) {
          console.log('valor default' + parseInt(value));
          switch (parseInt(value)) {
            case 0:
              wavePicker1 = 'sine'; // Senoidal
              break;
            case 1:
              wavePicker1 = 'square'; // Cuadrada
              break;
            case 2:
              wavePicker1 = 'sawtooth'; // Triangular
              break;
            case 3:
              wavePicker1 = 'triangle'; // Diente de sierra
              break;
          }
        }
      }
    });

    $('#waveform-knob2').knob({
      'min': 0,
      'max': 4,
      'step': 1,
      'change': function (value) {
        if (oscillator2 || audioContext) {
          console.log('valor default' + parseInt(value));
          switch (parseInt(value)) {
            case 0:
              wavePicker2 = 'sine'; // Senoidal
              break;
            case 1:
              wavePicker2 = 'square'; // Cuadrada
              break;
            case 2:
              wavePicker2 = 'sawtooth'; // Triangular
              break;
            case 3:
              wavePicker2 = 'triangle'; // Diente de sierra
              break;
          }
        }
      }
    });

    var stateOsc1 = false;
    $("#btnOnOsc1").on('change', function () {
      if ($(this).is(':checked')) {
        stateOsc1 = $(this).is(':checked');
        console.log('oscilador1: ' + stateOsc1)
      }
      else {
        stateOsc1 = $(this).is(':checked');
        console.log('oscilador1: ' + stateOsc1)
      }
    });

    var stateOsc2 = false;
    $("#btnOnOsc2").on('change', function () {
      if ($(this).is(':checked')) {
        stateOsc2 = $(this).is(':checked');
        console.log('oscilador2: ' + stateOsc2)
      }
      else {
        stateOsc2 = $(this).is(':checked');
        console.log('oscilador2: ' + stateOsc2)
      }
    });


    const note_names =
      [
        ["ラ", "", "A", ""],
        ["ラ#", "シ$\\flat$", "A#", "B$\\flat$"],
        ["シ", "", "B", ""],
        ["ド", "", "C", ""],
        ["ド#", "レ$\\flat$", "C#", "D$\\flat$"],
        ["レ", "", "D", ""],
        ["レ#", "ミ$\\flat$", "D#", "E$\\flat$"],
        ["ミ", "", "E", ""],
        ["ファ", "", "F", ""],
        ["ファ#", "ソ$\\flat$", "F#", "G$\\flat$"],
        ["ソ", "", "G", ""],
        ["ソ#", "ラ$\\flat$", "G#", "A$\\flat$"]
      ];

    document.addEventListener("keydown", (event) => {
      if (!keyIsPressed) {
        keyIsPressed = true;
        keyup = true;
        const key = event.key.toLowerCase();

        const keyMap3 = {
          q: 'C',
          2: 'C#',
          w: 'D',
          3: 'D#',
          e: 'E',
          r: 'F',
          5: 'F#',
          t: 'G',
          6: 'G#',
          y: 'A',
          7: 'A#',
          u: 'B'
        };
        const keyMap4 = {
          i: 'C',
          9: 'C#',
          o: 'D',
          0: 'D#',
          p: 'E',
          z: 'F',
          s: 'F#',
          x: 'G',
          d: 'G#',
          c: 'A',
          f: 'A#',
          v: 'B'
        };

        if (keyMap3.hasOwnProperty(key) || keyMap4.hasOwnProperty(key)) {

          var octave = keyMap3.hasOwnProperty(key) ? 3 : 4;
          const note = keyMap3.hasOwnProperty(key) ? keyMap3[key] : keyMap4[key];
          var freq = parseFloat(noteFreq[octave][note]);
          notePressed({ target: { dataset: { octave, note, frequency: freq } } });
        } else {
          console.log('No se reconoció la tecla');
        }

      }
    });

    document.addEventListener("keyup", (event) => {
      keyIsPressed = false;
      const key = event.key.toLowerCase();
      const keyMap3 = {
        q: 'C',
        2: 'C#',
        w: 'D',
        3: 'D#',
        e: 'E',
        r: 'F',
        5: 'F#',
        t: 'G',
        6: 'G#',
        y: 'A',
        7: 'A#',
        u: 'B'
      };
      const keyMap4 = {
        i: 'C',
        9: 'C#',
        o: 'D',
        0: 'D#',
        p: 'E',
        z: 'F',
        s: 'F#',
        x: 'G',
        d: 'G#',
        c: 'A',
        f: 'A#',
        v: 'B'
      };

      if (keyMap3.hasOwnProperty(key) || keyMap4.hasOwnProperty(key)) {
        var octave = keyMap3.hasOwnProperty(key) ? 3 : 4;
        const note = keyMap3.hasOwnProperty(key) ? keyMap3[key] : keyMap4[key];
        var freq = parseFloat(noteFreq[octave][note])
        //console.log('tecla presionada: ' + note + ' - frecuencia: ' + freq + ' - octava: ' + octave);
        noteReleased({ target: { dataset: { octave, note, frequency: freq } } });
      } else {
        console.log('No se reconoció la tecla');
      }

    });

    setup();

    // -------------------------------------------------------
    // functions
    // -------------------------------------------------------

    function createNoteTable() {

      let noteFreq = [];
      for (let octave = 0; octave < 9; octave++) {
        noteFreq[octave] = [];
      }

      for (let n = 0; n < 88; n++) {

        const frequency = getAudioFrequency(n);

        let octave = parseInt(n / 12);
        if (n % 12 >= 3) {
          octave++;
        }

        const note_name_sharp_english = note_names[n % 12][2];
        noteFreq[octave][note_name_sharp_english] = frequency;
      }

      return noteFreq;
    }

    function getAudioFrequency(n) {
      return 27.5 * (Math.pow(Math.pow(2, 1 / 12), n));
    }

    function setup() {
      noteFreq = createNoteTable();

      noteFreq.forEach(function (keys, idx) {

        const keyList = Object.entries(keys);
        const octaveElem = document.createElement("div");
        octaveElem.className = "octave";

        for (let i = 0; i < keyList.length; i++) {

          const keySetElem = document.createElement("div");
          keySetElem.className = "key-set-parent";

          const whiteKey = keyList[i];
          const whiteKeyName = whiteKey[0];

          const whiteKeyElem = createKey(whiteKeyName, idx, whiteKey[1], 'white-key');
          keySetElem.appendChild(whiteKeyElem);

          if (whiteKeyName === 'A' || whiteKeyName === 'C' || whiteKeyName === 'D' ||
            whiteKeyName === 'F' || whiteKeyName === 'G') {

            const blackKey = keyList[++i];

            if (blackKey != undefined) {
              const blackKeyName = blackKey[0];
              const blackKeyElem = createKey(blackKeyName, idx, blackKey[1], 'black-key');
              keySetElem.appendChild(blackKeyElem);
            }
          }

          octaveElem.appendChild(keySetElem);
        }

        keyboard.appendChild(octaveElem);
      });

      document.querySelector("div[data-note='F'][data-octave='5']").scrollIntoView(false);

      sineTerms = new Float32Array([0, 0, 1, 0, 1]);
      cosineTerms = new Float32Array(sineTerms.length);
      customWaveform = audioContext.createPeriodicWave(cosineTerms, sineTerms);
    }

    function createKey(note, octave, freq, keyColor) {
      const keyElement = document.createElement("div");
      const labelElement = document.createElement("div");

      if (keyColor === 'black-key') {
        keyElement.className = "key black-key";
      } else {
        keyElement.className = "key";
      }

      keyElement.dataset["octave"] = octave;
      keyElement.dataset["note"] = note;
      keyElement.dataset["frequency"] = freq;

      labelElement.innerHTML = note + "<sub>" + octave + "</sub>";
      keyElement.appendChild(labelElement);

      keyElement.addEventListener("mousedown", notePressed, false);
      keyElement.addEventListener("mouseup", noteReleased, false);
      keyElement.addEventListener("mouseleave", noteReleased, false);

      keyElement.addEventListener("touchstart", notePressed, false);
      keyElement.addEventListener("touchend", noteReleased, false);
      keyElement.addEventListener("touchmove", noteReleased, false);
      keyElement.addEventListener("touchcancel", noteReleased, false);

      return keyElement;
    }

    class Oscillator1 {

      constructor(type, frequency, gainNode) {
        this.oscillator1 = audioContext.createOscillator();
        this.oscillator1.connect(gainNode);

        if (type == null) {
          this.oscillator1.setPeriodicWave(customWaveform);
        } else {
          this.oscillator1.type = type;
        }

        this.oscillator1.frequency.value = frequency;
      }

      start() {
        this.oscillator1.start();
      }

      stop(t) {
        this.oscillator1.stop(t);
      }
    }

    class Oscillator2 {

      constructor(type, frequency, gainNode) {
        this.oscillator2 = audioContext.createOscillator();
        this.oscillator2.connect(gainNode);

        if (type == null) {
          this.oscillator2.setPeriodicWave(customWaveform);
        } else {
          this.oscillator2.type = type;
        }

        this.oscillator2.frequency.value = frequency;
      }

      start() {
        this.oscillator2.start();
      }

      stop(t) {
        this.oscillator2.stop(t);
      }
    }



    function notePressed(event) {

      //event.preventDefault();

      const dataset = event.target.dataset;

      if (dataset["pressed"]) {
        return;
      }

      dataset["pressed"] = "yes";

      const octave = dataset["octave"];
      const note = dataset["note"];
      const frequency = dataset["frequency"];

      const oscillator = audioContext.createOscillator();

      const t_pressed = audioContext.currentTime;
      const volume = parseFloat(volumeControl.value);
      const timeScale = parseFloat(timeScaleControl.value);
      const attackDuration = parseFloat(attackControl.value) * timeScale;
      const decayDuration = parseFloat(decayControl.value) * timeScale;
      const sustainLevel = parseFloat(sustainControl.value);

      // Attack -> Decay -> Sustain
      const gainNode = audioContext.createGain();
      gainNode.connect(audioContext.destination);
      gainNode.gain.setValueAtTime(0, t_pressed);
      gainNode.gain.linearRampToValueAtTime(volume, t_pressed + attackDuration);
      gainNode.gain.setTargetAtTime(sustainLevel * volume, t_pressed + attackDuration, decayDuration);

      oscillator.connect(gainNode);
      const keyID = note + octave;
      /*OSCILADOR 1*/

      if (!stateOsc1 && !stateOsc2) {
        alert('Encienda alguno de los 2 Osciladores')

      } else {
        if (stateOsc1) {
          const typeOsc1 = wavePicker1
          const oscillator1 = new Oscillator1(typeOsc1, frequency, gainNode);
          oscillator1.start();
          oscillatorMap.set(keyID, oscillator1);

        }

        // const type = wavePicker1.options[wavePicker1.selectedIndex].value;
        /*OSCILADOR 2*/
        if (stateOsc2) {
          const typeOsc2 = wavePicker2
          const oscillator2 = new Oscillator2(typeOsc2, frequency, gainNode);
          oscillator2.start();
          oscillatorMap.set(keyID, oscillator2);
        }
      }

      gainNodeMap.set(keyID, gainNode);

    }

    function noteReleased(event) {

      //event.preventDefault();

      const dataset = event.target.dataset;

      if (keyup) {
        keyup = false;
        dataset["pressed"] = "yes";
      }

      if (!dataset["pressed"]) {
        return;
      }

      delete dataset["pressed"];

      const octave = dataset["octave"];
      const note = dataset["note"];
      const frequency = dataset["frequency"];
      const keyID = note + octave;

      const oscillator1 = oscillatorMap.get(keyID);
      const oscillator2 = oscillatorMap.get(keyID);
      const gainNode = gainNodeMap.get(keyID);

      const t_released = audioContext.currentTime;
      const timeScale = parseFloat(timeScaleControl.value);
      const releaseDuration = parseFloat(releaseControl.value) * timeScale;

      gainNode.gain.cancelScheduledValues(t_released);
      gainNode.gain.setValueAtTime(gainNode.gain.value, t_released);
      gainNode.gain.linearRampToValueAtTime(0, t_released + releaseDuration);

      if (stateOsc1)
        oscillator1.stop(t_released + releaseDuration);

      if (stateOsc2)
        oscillator2.stop(t_released + releaseDuration);
    }
  </script>
</body>

</html>